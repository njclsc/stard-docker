volatile:内存可见性

1：每个线程都有自己独立的缓存空间。
2: 当多个线程操作共享数据时，由于把共享数据读取到了自己的独立缓存
	彼此不可见，固出现内存不可见问题。通过synchronized可以刷新缓存，但是
	效率低。
3：当用volatile修饰后的共享数据，所有线程都会从主存中读取 而不是从线程的独立缓存读取

--------------------------

cpu中的每一个核都有缓存，且缓存又分lv1,lv2, l3...
进程：分配资源的基本单位
线程：调度资源的基本单位。

按块读取：
	程序局部性原理，可以提高效率，充分发挥cpu针脚一次性读取更多数据能力

缓存行概念：
	计算单元与寄存器需要访问相关资源时，会先访问1,2，3级cpu缓存，如果都没有再到主存中读取到3,
	2,1级缓存中，最后读到计算单元和寄存器中使用。
	在读资源时，根据资源大小按块来读取到cpu中 即：缓存行的概念
	
	缓存行越大，局部性空间效率越高，但读取时间慢
	缓存行越小，局部性空间效率越低，但读取时间块
	目前多用 64字节作为缓存行大小。

	多个线程的共享数据位于同一缓存行时，其中一个线程改变了其中一个值，
	会通知所有拥有共享 数据的线程，使其重新从主存中读取新值。性能偏慢
	反之不位于同一缓存行，修改后 不会通知让其重新读取 各自在各自的缓存行中。性能偏快

缓存一致性协议[mesi]：

指令重排序：
	cpu提高效率，乱序执行指令，比如：指令一要读取数据等待返回中，指令2会先执行
	jvm规定重排序必须遵守的规则:
		程序次序规则：同一个线程内，按照代码出现顺序，先后执行， 因为要考虑到分支和循环结构
		管理锁定规则：一个unlock操作先于后面对同一个锁的操作
		volatile变量规则：对此变量的写操作先发生于读操作。
		线程启动：线程的start()方法先于此线程的所有操作。
		线程停止：此线程的所有操作都先于此操作
		线程中断：interrupt()方法先于被中断代码的检测中。
		对象终结规则：对象初始化先于finalize()方法
		传递：代码中a先于b,b先于c,那么a先于c

内存屏障：
	jvm必须实现4个逻辑屏障:
		LoadLoad:第一，二条指令为读，不能重排序
		StoreStore：第一，二条指令为写，不能重排序
		LoadStore：第一，二条指令为读写，不能重排序
		StoreLoad：第一，二条指令为写读，不能重排序
	例如被volatile修饰后：
		---------StoreStoreBarrier--------
			volatile
		---------StoreStoreBarrier--------

		---------LoadLoadBarrier--------
			volatile
		---------LoadLoadBarrier--------
	5层实现：
		1：java代码, 		volatile int i;
		2: ByteCode, 字节码	ACC_VOLATILE
		3: jvm规范,		jvm内存屏障
		4：HotSpot实现		汇编调用
		5：cpu级别		mesi总线锁支持












